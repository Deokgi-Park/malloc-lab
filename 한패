
CS 213, 2001년 가을
Malloc Lab: 동적 저장 할당기 작성
할당일: 2001년 11월 2일 금요일, 마감일: 2001년 11월 20일 화요일, 오후 11시 59분
Cory Williams (cgw@andrew.cmu.edu)가 이 과제를 이끌고 있습니다.
1 소개
이 랩에서는 C 프로그램을 위한 동적 저장 할당기, 즉 malloc, free 및 realloc 루틴의 자체 버전을 작성하게 됩니다. 창의적으로 설계 공간을 탐색하고 올바르고 효율적이며 빠른 할당기를 구현하는 것이 권장됩니다.
2 로지스틱스
최대 두 명의 사람들과 함께 작업할 수 있습니다. 과제에 대한 모든 명확화 및 수정은 강좌 웹 페이지에 게시됩니다.
3 전달 지침
사용자별로 malloclab-handout.tar 파일을 다운로드하는 방법을 설명하는 단락을 여기에 삽입하십시오.
먼저 작업할 보호된 디렉토리로 malloclab-handout.tar를 복사한 다음 다음 명령을 실행하십시오: tar xvf malloclab-handout.tar. 이렇게하면 여러 파일이 디렉토리에 풀립니다. 수정하고 제출해야 할 유일한 파일은 mm.c입니다. mdriver.c 프로그램은 솔루션의 성능을 평가할 수 있는 드라이버 프로그램입니다. make 명령을 사용하여 드라이버 코드를 생성하고 ./mdriver -V 명령을 사용하여 실행하십시오. (-V 플래그는 유용한 요약 정보를 표시합니다.)
mm.c 파일을 보면 프로그래밍 팀에 대한 식별 정보를 삽입할 수 있는 C 구조체 팀이 있습니다. 이것을 잊지 않도록 바로 작업하십시오.
랩을 완료하면 당신은 해결책을 포함하는 하나의 파일 (mm.c)만 제출합니다.
4 랩 작업 방법
동적 저장 할당기는 mm.h에 선언되고 mm.c에서 정의된 다음 네 가지 함수로 구성됩니다.
int mm_init(void);
void *mm_malloc(size_t size);
void mm_free(void *ptr);
void *mm_realloc(void *ptr, size_t size);
주어진 mm.c 파일은 생각할 수 있는 가장 간단하지만 여전히 기능적으로 정확한 malloc 패키지를 구현합니다. 이것을 시작점으로 사용하여 다음 시맨틱을 준수하도록 이러한 함수를 수정하십시오.
• mm init: mm malloc, mm realloc 또는 mm free를 호출하기 전에 응용 프로그램 프로그램 (즉, 구현을 평가하기 위해 사용할 추적 주도 드라이버 프로그램)은 초기 힙 영역 할당과 같은 필요한 초기화를 수행하기 위해 mm init를 호출합니다. 초기화를 수행하는 데 문제가 있으면 반환 값은 -1이어야하며 그렇지 않으면 0이어야합니다.
• mm malloc: mm malloc 루틴은 적어도 크기 바이트의 할당된 블록 페이로드에 대한 포인터를 반환합니다. 할당된 전체 블록은 힙 영역 내에 있어야하며 다른 할당된 청크와 겹치지 않아야합니다.
우리는 당신의 구현을 표준 C 라이브러리 (libc)에서 제공하는 malloc 버전과 비교할 것입니다. libc malloc은 항상 8 바이트에 정렬된 페이로드 포인터를 반환하므로 당신의 malloc 구현도 마찬가지로 8 바이트에 정렬된 포인터를 반환해야합니다.
• mm free: mm free 루틴은 ptr이 가리키는 블록을 해제합니다. 아무 것도 반환하지 않습니다. 이 루틴은 ptr이 이전에 mm malloc 또는 mm realloc을 호출하여 반환되었으며 아직 해제되지 않았을 때만 보장됩니다.
• mm realloc: mm realloc 루틴은 다음과 같은 제약 조건이 있는 적어도 크기 바이트의 할당된 영역에 대한 포인터를 반환합니다.
– ptr이 NULL이면 호출은 mm malloc(size)과 동일합니다.
– 크기가 0과 같으면 호출은 mm free(ptr)와 동일합니다.
– ptr이 NULL이 아니면 이전에 mm malloc 또는 mm realloc을 호출하여 반환되어야합니다.
mm realloc 호출은 ptr이 가리키는 메모리 블록 (이전 블록)의 크기를 크기 바이트로 변경하고 새 블록의 주소를 반환합니다. 새 블록의 주소는 구현에 따라 이전 블록과 동일할 수도 있고 다를 수도 있습니다. 이전 블록의 내부 단편화 양과 realloc 요청의 크기에 따라 달라집니다.
새 블록의 내용은 이전 및 새 크기의 최소값까지 이전 ptr 블록의 내용과 동일합니다. 나머지는 초기화되지 않습니다. 예를 들어, 이전 블록이 8 바이트이고 새 블록이 12 바이트이면 새 블록의 처음 8 바이트는 이전 블록의 처음 8 바이트와 동일하며 나머지 4 바이트는 초기화되지 않습니다. 마찬가지로, 이전 블록이 8 바이트이고 새 블록이 4 바이트이면 새 블록의 내용은 이전 블록의 처음 4 바이트와 동일합니다.
이러한 의미론은 해당하는 libc malloc, realloc 및 free 루틴의 의미론과 일치합니다. 완전한 문서에 대한 셸에 man malloc을 입력하십시오.
5 힙 일관성 검사기
동적 메모리 할당기는 일관성이나 효율성을 보장하기가 매우 까다롭습니다. 이는 많은 유형의 포인터 조작을 포함하기 때문입니다. 힙을 스캔하고 일관성을 확인하는 힙 검사기를 작성하는 것이 매우 도움이됩니다.
힙 검사기가 확인할 수있는 몇 가지 예는 다음과 같습니다.
• 자유 목록의 모든 블록이 자유로 표시되었습니까?
• 어떤 연속적인 무료 블록이 병합되지 않고 남아 있습니까?
• 모든 무료 블록이 실제로 자유 목록에 있습니까?
• 자유 목록의 포인터가 유효한 무료 블록을 가리키고 있습니까?
• 할당된 블록이 겹치는지 확인하십시오.
• 힙 블록의 포인터가 유효한 힙 주소를 가리키고 있습니까?
당신의 힙 검사기는 mm.c의 함수 int mm check(void)로 구성됩니다. 당신이 신중하게 고려하는 불변성 또는 일관성 조건을 확인합니다. 힙이 일관성이 있는 경우에만 0이 아닌 값을 반환합니다. 권장 사항으로 나열된 항목에만 국한되지 않으며 모두를 확인할 필요는 없습니다. mm check가 실패할 때 오류 메시지를 출력하는 것이 좋습니다.
이 일관성 검사기는 개발 중에 자체 디버깅을 위한 것입니다. mm.c를 제출할 때 mm check 호출을 제거하여 처리량이 느려지지 않도록하십시오. mm check 함수에 스타일 포인트가 제공됩니다. 무엇을 확인하는지 설명하는 주석을 추가하고 문서화하십시오.
6 지원 루틴
memlib.c 패키지는 동적 메모리 할당기를 위해 메모리 시스템을 시뮬레이트합니다. memlib.c에서 다음 함수를 호출 할 수 있습니다.
• void *mem sbrk(int incr): incr 바이트로 힙을 확장하고, incr이 양의 정수이고 0이 아닌 경우 새로 할당된 힙 영역의 첫 번째 바이트에 대한 일반적인 포인터를 반환합니다. 의미는 Unix sbrk 함수와 동일하지만 mem sbrk는 양의 정수 인수 만 수용합니다.
• void *mem heap lo(void): 힙의 첫 번째 바이트에 대한 일반적인 포인터를 반환합니다.
• void *mem heap hi(void): 힙의 마지막 바이트에 대한 일반적인 포인터를 반환합니다.
• size t mem heapsize(void): 힙의 현재 크기를 바이트 단위로 반환합니다.
• size t mem pagesize(void): 시스템의 페이지 크기를 바이트 단위로 반환합니다 (Linux 시스템의 경우 4K).
7 추적 주도 드라이버 프로그램
malloclab-handout.tar 배포에서 드라이버 프로그램 mdriver.c는 mm.c 패키지의 정확성, 공간 활용 및 처리량을 테스트합니다. 드라이버 프로그램은 mm malloc, mm realloc 및 mm free 루틴을 테스트하는 trace 파일 집합에 의해 제어됩니다. 우리가 평가 할 때 사용할 동일한 trace 파일이 드라이버와 함께 제공됩니다.
드라이버 mdriver.c는 다음과 같은 명령 줄 인수를 허용합니다.
• -t <tracedir>: 디폴트 트레이스 파일을 tracedir 디렉토리에서 사용하도록 설정합니다. config.h에서 정의된 디폴트 디렉토리 대신 사용합니다.
• -f <tracefile>: 기본 트레이스 파일 대신 특정 트레이스 파일을 사용하여 테스트합니다.
• -h: 명령 줄 인수 요약을 인쇄합니다.
• -l: 공간 활용과 함께 libc malloc을 실행하고 측정합니다.
• -v: 자세한 출력. 각 트레이스 파일에 대한 성능 요약을 압축 된 표로 인쇄합니다.
• -V: 더 자세한 출력. 각 트레이스 파일이 처리 될 때마다 추가 진단 정보를 인쇄합니다. mm.c에서 어느 트레이스 파일이 malloc 패키지의 실패를 유발하는지 확인하는 데 유용합니다.
8 프로그래밍 규칙
• mm.c의 인터페이스를 변경해서는 안됩니다.
• 코드에서 메모리 관리 관련 라이브러리 호출 또는 시스템 호출을 호출해서는 안됩니다. 이것은 코드 내의 malloc, calloc, free, realloc, sbrk, brk 또는 이러한 호출의 변형을 포함합니다.
• 전역 또는 정적 복합 데이터 구조 (배열, 구조체, 트리 또는 목록)를 정의해서는 안됩니다. 그러나 mm.c에서 정수, 부동 소수점 및 포인터와 같은 전역 스칼라 변수를 선언하는 것은 허용됩니다.
• libc malloc 패키지는 항상 8 바이트 경계에 정렬된 블록을 반환하기 때문에 할당기는 항상 8 바이트 경계에 정렬된 포인터를 반환해야합니다. 드라이버가 이 요구 사항을 강제 할 것입니다.
9 평가
규칙을 어겼거나 코드가 버그가 있어 드라이버를 크래시시키는 경우 점수가 없습니다. 그렇지 않으면 등급은 다음과 같이 계산됩니다.
• 정확성 (20 점). 솔루션이 드라이버 프로그램에 의해 수행되는 정확성 테스트를 통과하면 전체 점수를받습니다. 각 올바른 트레이스에 대해 부분 점수를받습니다.
• 성능 (35 점). 두 가지 성능 메트릭이 솔루션을 평가하는 데 사용됩니다.
– 공간 활용 : 드라이버가 사용하는 메모리의 총량 (즉, mm malloc 또는 mm realloc을 통해 할당되었지만 아직 mm free를 통해 해제되지 않음)과 할당기에 의해 사용된 힙의 크기 사이의 최대 비율. 최적 비율은 1입니다. 이 비율을 최대한 최적화하기 위해 내부 조각화를 최소화하는 좋은 정책을 찾아야합니다.
– 처리량 : 초당 완료된 작업의 평균 수.
드라이버 프로그램은 성능 지표를 요약하여 성능 지수 P를 계산합니다.
P = wU + (1 − w) min
(
1, T
Tlibc
)
여기서 U는 공간 활용, T는 처리량이며 Tlibc는 기본 트레이스에서 시스템의 libc malloc의 추정 처리량입니다. 이 성능 지수는 공간 활용을 처리량보다 우선시하며 기본값으로 w = 0.6입니다.
메모리와 CPU 사이클이 모두 비싼 시스템 리소스임을 고려하여 이 공식을 채택하여 메모리 사용률과 처리량의 균형잡힌 최적화를 촉진합니다. 이상적으로는 성능 지수가 P = w + (1 − w) = 1 또는 100%에 도달할 것입니다. 각 메트릭이 성능 지수에 각각 w와 1 - w를 최대로 기여 할 수 있기 때문에 메모리 사용률 또는 처리량을 극단적으로 최적화해서는 안됩니다. 좋은 점수를받으려면 메모리 사용률과 처리량 사이의 균형을 유지해야합니다.
• 스타일 (10 점).
– 코드는 기능으로 분해되어 있고 가능한 한 적은 전역 변수를 사용해야합니다.
– 코드는 자유 및 할당된 블록의 구조, 자유 목록의 구성 및 할당기가 자유 목록을 어떻게 조작하는지에 대한 헤더 주석으로 시작해야합니다. 각 함수는 함수가 수행하는 작업을 설명하는 헤더 주석으로 시작해야합니다.
– 각 하위 루틴은 무엇을하는지 및 어떻게하는지를 설명하는 헤더 주석을 가져야합니다.
– 힙 일관성 검사기 mm check는 철저하고 잘 문서화되어야합니다.
좋은 힙 일관성 검사기에는 5 점이 부여되고 좋은 프로그램 구조 및 주석에는 5 점이 부여됩니다.
10 제출 지침
학생들이 해결책 mm.c 파일을 어떻게 제출해야하는지 설명하는 단락을 여기에 삽입하십시오.
11 힌트
• mdriver -f 옵션을 사용하십시오. 초기 개발 중에 작은 추적 파일을 사용하면 디버깅 및 테스트를 단순화할 수 있습니다. 이러한 작은 추적 파일 (short1,2-bal.rep)이 포함되어 있습니다. 처음에는 작업을해야합니다.
• mdriver -v 및 -V 옵션을 사용하십시오. -v 옵션을 사용하면 각 추적 파일에 대한 자세한 요약을 제공합니다. -V는 또한 각 추적 파일이 처리 될 때 추가 진단 정보를 표시합니다. 이는 오류를 분리하는 데 도움이됩니다.
• gcc -g로 컴파일하고 디버거를 사용하십시오. 디버거는 경계를 잘못 처리하는 등의 여러 오류를 찾는 데 유용합니다.
• 기존 할당자의 라이브러리 코드를 살펴보십시오. glibc의 malloc 구현은 malloc.c에 있습니다.
• 이번 프로젝트는 매우 복잡 할 수 있습니다. 공식과 힌트를 사용하십시오. 아직도 도움이 필요하면 TA에게 문의하십시오.

